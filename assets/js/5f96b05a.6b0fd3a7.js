"use strict";(self.webpackChunkpaima_engine_docs=self.webpackChunkpaima_engine_docs||[]).push([[705],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=i,f=u["".concat(l,".").concat(m)]||u[m]||d[m]||r;return n?a.createElement(f,o(o({ref:t},p),{},{components:n})):a.createElement(f,o({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5290:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const r={},o="ERC721 CDEs",s={unversionedId:"home/Reacting to Events/Chain Data Extensions/ERC721",id:"home/Reacting to Events/Chain Data Extensions/ERC721",title:"ERC721 CDEs",description:"- ERC721, keeping track of NFT ownership for a specified ERC721 contract at the currently processed blockheight, as well as generating scheduled inputs for newly minted NFTs;",source:"@site/docs/home/3 - Reacting to Events/2 - Chain Data Extensions/3 - ERC721.md",sourceDirName:"home/3 - Reacting to Events/2 - Chain Data Extensions",slug:"/home/Reacting to Events/Chain Data Extensions/ERC721",permalink:"/home/Reacting to Events/Chain Data Extensions/ERC721",draft:!1,editUrl:"https://github.com/PaimaStudios/paima-engine-docs/docs/home/3 - Reacting to Events/2 - Chain Data Extensions/3 - ERC721.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ERC20 CDEs",permalink:"/home/Reacting to Events/Chain Data Extensions/ERC20"},next:{title:"Generic CDE",permalink:"/home/Reacting to Events/Chain Data Extensions/Generic"}},l={},c=[{value:"ERC721",id:"erc721",level:2},{value:"Example",id:"example",level:3},{value:"Meaning",id:"meaning",level:3},{value:"Paima Concise format",id:"paima-concise-format",level:3},{value:"Utility functions",id:"utility-functions",level:3},{value:"Capturing nft burn events",id:"capturing-nft-burn-events",level:2}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"erc721-cdes"},"ERC721 CDEs"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#erc721"},"ERC721"),", keeping track of NFT ownership for a specified ERC721 contract at the currently processed blockheight, as well as generating scheduled inputs for newly minted NFTs;")),(0,i.kt)("h2",{id:"erc721"},"ERC721"),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'extensions:\n  - name: "My NFT Contract"\n    type: "erc721"\n    contractAddress: "0x01...EF"\n    startBlockHeight: 7654321\n    scheduledPrefix: "newnft"\n')),(0,i.kt)("h3",{id:"meaning"},"Meaning"),(0,i.kt)("p",null,"This extension allows you to track NFT ownership for any ERC721-compatible contract. You may also use it with PaimaERC721 contracts, which additionally allow you to specify an arbitrary string when minting an NFT ","\u2013"," this extension type supports retrieving that string using scheduled inputs."),(0,i.kt)("h3",{id:"paima-concise-format"},"Paima Concise format"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"prefix|contractAddress|tokenId|mintData\n")),(0,i.kt)("p",null,"where:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prefix")," is the ",(0,i.kt)("inlineCode",{parentName:"li"},"scheduledPrefix")," specified in the config file,"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"contractAddress")," is the address of the contract (also specified in the config file),"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tokenId")," is the ID of the newly minted token (in base 10),"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mintData")," is the string emitted when the NFT was minted for PaimaERC721 NFTs (used for specifying the type of Stateful NFT). For classical ERC721 contracts, it will always be an empty string.")),(0,i.kt)("h3",{id:"utility-functions"},"Utility functions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getNftOwner"),", to fetch the address which owns the NFT with the specified token ID:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export async function getNftOwner(\n  readonlyDBConn: PoolClient,\n  cdeName: string,\n  nftId: bigint\n): Promise<string | null>;\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isNftOwner"),", to check whether the specified address owns the specified NFT:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export async function isNftOwner(\n  readonlyDBConn: PoolClient,\n  cdeName: string,\n  nftId: bigint,\n  ownerAddress: string\n): Promise<boolean>;\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getOwnedNfts"),", to fetch a list of token IDs of NFTs owned by the specified wallet address:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export async function getOwnedNfts(\n  readonlyDBConn: PoolClient,\n  cdeName: string,\n  ownerAddress: string\n): Promise<bigint[]>;\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getAllOwnedNfts"),", to fetch a list of ",(0,i.kt)("inlineCode",{parentName:"li"},"tokenId"),",",(0,i.kt)("inlineCode",{parentName:"li"},"cdeName")," pairs of NFTs owned by the specified wallet address across all chain data extensions:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export async function getAllOwnedNfts(\n  readonlyDBConn: PoolClient,\n  ownerAddress: string\n): Promise<\n  {\n    cdeName: string;\n    tokenId: bigint;\n  }[]\n>;\n")),(0,i.kt)("h2",{id:"capturing-nft-burn-events"},"Capturing nft burn events"),(0,i.kt)("p",null,"There is no separate nft burn event in the ERC721 contract, but a burn is just a transfer to the zero address (",(0,i.kt)("inlineCode",{parentName:"p"},"'0x0000000000000000000000000000000000000000'"),"). Transfer events can be captured using a ",(0,i.kt)("a",{parentName:"p",href:"/home/Reacting%20to%20Events/Chain%20Data%20Extensions/Generic"},"generic CDE")," and then filtered based on the ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," address. Note that you will need to provide a built abi (it is built during deployment). Example of a generic extension entry:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'  - name: "NFT transfer"\n    type: generic\n    contractAddress: "0x01...EF"\n    startBlockHeight: 7654321\n    abiPath: "./abis/ERC721.json"\n    eventSignature: "Transfer(address,address,uint256)"\n    scheduledPrefix: nftTransfer\n')))}d.isMDXComponent=!0}}]);