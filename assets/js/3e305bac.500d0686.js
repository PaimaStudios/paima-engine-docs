"use strict";(self.webpackChunkpaima_engine_docs=self.webpackChunkpaima_engine_docs||[]).push([[875],{3905:(e,a,t)=>{t.d(a,{Zo:()=>p,kt:()=>h});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=n.createContext({}),m=function(e){var a=n.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):o(o({},a),e)),t},p=function(e){var a=m(e.components);return n.createElement(l.Provider,{value:a},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},d=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=m(t),d=r,h=u["".concat(l,".").concat(d)]||u[d]||c[d]||i;return t?n.createElement(h,o(o({ref:a},p),{},{components:t})):n.createElement(h,o({ref:a},p))}));function h(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=d;var s={};for(var l in a)hasOwnProperty.call(a,l)&&(s[l]=a[l]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var m=2;m<i;m++)o[m]=t[m];return n.createElement.apply(null,o)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"},2322:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var n=t(7462),r=(t(7294),t(3905));const i={sidebar_position:1},o="Read and Write to L2 state",s={unversionedId:"home/read-write-L2-state/base-format",id:"home/read-write-L2-state/base-format",title:"Read and Write to L2 state",description:"To be a rollup, Paima state has to eventually be written to the L1. As a sovereign rollup, the way the data is stored is fairly simple (calling a contract function that simply emits its input as an event) and we provide a way to generate a grammar for this data.",source:"@site/docs/home/2-read-write-L2-state/1-base-format.md",sourceDirName:"home/2-read-write-L2-state",slug:"/home/read-write-L2-state/base-format",permalink:"/home/read-write-L2-state/base-format",draft:!1,editUrl:"https://github.com/PaimaStudios/paima-engine-docs/docs/home/2-read-write-L2-state/1-base-format.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Paima Batcher",permalink:"/home/setup/paima-bacher"},next:{title:"Sequential State Identifier",permalink:"/home/read-write-L2-state/parallelism"}},l={},m=[{value:"Read data",id:"read-data",level:2},{value:"Defining a grammar",id:"defining-a-grammar",level:3},{value:"Manually parsing",id:"manually-parsing",level:3},{value:"Example usage",id:"example-usage",level:4},{value:"Supported characters",id:"supported-characters",level:3},{value:"Concise Builder",id:"concise-builder",level:2}],p={toc:m},u="wrapper";function c(e){let{components:a,...t}=e;return(0,r.kt)(u,(0,n.Z)({},p,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"read-and-write-to-l2-state"},"Read and Write to L2 state"),(0,r.kt)("p",null,"To be a rollup, Paima state has to eventually be written to the L1. As a sovereign rollup, the way the data is stored is fairly simple (calling a contract function that simply emits its input as an event) and we provide a way to generate a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Formal_grammar"},"grammar")," for this data."),(0,r.kt)("p",null,"Paima has its own format for representing L2 data called Paima Concise that resembles a bar-separated string (ex: ",(0,r.kt)("inlineCode",{parentName:"p"},"c|3|100|"),"). This was chosen as"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"It is human-readable, which not only helps with coding & debugging, but also helps users verify the content of the string when signing from their wallet such as Metamask"),(0,r.kt)("li",{parentName:"ol"},"It is easy to combine with many parsing tools (given the prevalence of CSV) and so it avoids having to write a lot of custom parers to Paima Concise in multiple programming languages & tools"),(0,r.kt)("li",{parentName:"ol"},"It is easy to combine with other formats if desired. For example, you could use ",(0,r.kt)("a",{parentName:"li",href:"https://protobuf.dev/"},"protobuf")," to encode one of the fields in the bar-separated string (although we recommend using PaimaParser defined below instead)")),(0,r.kt)("p",null,"Paima comes with two classes to help generate these bar-separated strings"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// create the bar-separated string\nimport { builder } from 'paima-engine/paima-concise';\n// parse the bar-separated string\nimport { consumer } from 'paima-engine/paima-concise';\n")),(0,r.kt)("h2",{id:"read-data"},"Read data"),(0,r.kt)("h3",{id:"defining-a-grammar"},"Defining a grammar"),(0,r.kt)("p",null,"We allow defining more complex grammars on top of this notation using ",(0,r.kt)("inlineCode",{parentName:"p"},"PaimaParser"),". The process has two steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Define a base grammar (which Paima will then internally convert into ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form"},"EBNF")," form)"),(0,r.kt)("li",{parentName:"ol"},"Define how to parse tokens in this grammar (recursively defined)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import type { ParserRecord } from 'paima-sdk/paima-concise';\nimport { PaimaParser } from 'paima-sdk/paima-concise';\n\n// First, define your grammar which Paima will turn into EBNF form internally\nconst myGrammar = `\ncreatedLobby        = c|numOfRounds|isPractice?\njoinedLobby         = j|*lobbyID\n`;\n\n// Setup the type definitions for the result of parsing\nexport interface CreatedLobbyInput {\n  input: 'createdLobby';\n  numOfRounds: number;\n  isPractice: boolean;\n}\nexport interface JoinedLobbyInput {\n  input: 'joinedLobby';\n  lobbyID: string;\n}\nexport interface InvalidInput {\n  input: 'invalidString';\n}\nexport type ParsedSubmittedInput =\n  | CreatedLobbyInput\n  | JoinedLobbyInput\n  | InvalidInput;\n\n\n// First, define how to parse the leaf tokens in this grammar\n// Note: objects keys here MUST match the names using in your grammar\n// ex: `numOfRounds` key here defines which function to use to parse the token defined in the grammar above\nconst createdLobby: ParserRecord<CreatedLobbyInput> = {\n  numOfRounds: PaimaParser.NumberParser(3, 1000),\n  isPractice: PaimaParser.TrueFalseParser(false),\n};\nconst joinedLobby: ParserRecord<JoinedLobbyInput> = {\n  lobbyID: PaimaParser.NCharsParser(12, 12),\n};\n\n// Define the top-level tokens\nconst parserCommands: Record<string, ParserRecord<ParsedSubmittedInput>> = {\n  createdLobby, // this means parse the key \"createLobby\" using the \"createLobby\" object defined above\n  joinedLobby\n};\n\nconst myParser = new PaimaParser(myGrammar, parserCommands);\n\nfunction parse(s: string): ParsedSubmittedInput {\n  try {\n    const parsed = myParser.start(s);\n    return { input: parsed.command, ...parsed.args } as any;\n  } catch (e) {\n    console.log(e, 'Parsing error');\n    return { input: 'invalidString' };\n  }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"PaimaParser")," comes with many of the common token parsing utility functions you need"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ArrayParser(iter: { perItemParser: ParserCommandExec })")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TrueFalseParser(defaultValue?: boolean)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DefaultRoundLength(blockTimeInSecs: number)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"NumberParser(min?: number, max?: number)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"NCharsParser(minChars: number, maxChars: number)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegexParser(regex: RegExp)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HexParser()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"WalletAddress()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"EnumParser(values: readonly string[], transform?: (value: string) => string)"))),(0,r.kt)("h3",{id:"manually-parsing"},"Manually parsing"),(0,r.kt)("p",null,"Although using a grammar is often the best way to go, you can also manually parse the data for use-cases where the encoding cannot be represented using the grammar system."),(0,r.kt)("p",null,"You can define your own parser as they satisfy the type ",(0,r.kt)("inlineCode",{parentName:"p"},"ParserCommandExec")," defined below"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"type ParserValues = string | boolean | number | null;\ntype ParserCommandExec = (keyName: string, input: string) => ParserValues | ParserValues[];\n")),(0,r.kt)("p",null,"If you want to define your own parse functions, we suggest the ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/parsimmon"},"parsimmon")," NPM package."),(0,r.kt)("h4",{id:"example-usage"},"Example usage"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import P from 'parsimmon';\nimport { consumer } from 'paima-engine/paima-concise';\n\nconst pRoundNumber = P.digits.map(Number).chain(n => {\n  if (n >= 1 && n <= 1000) return P.succeed(n);\n  else return P.fail(`Round Number must be above 0`);\n});\nconst pMaybeBool = P.string('T').or(P.string('F')).or(P.succeed(null));\n\nfunction parseSubmitTurn(c: ConciseConsumer): SubmittedTurnInput {\n  const roundNumber = tryParse(c.nextValue(), pRoundNumber);\n  const isPractice = tryParse(c.nextValue(), pMaybeBool);\n  return {\n    input: 'createLobby',\n    numOfRounds,\n    isPractice,\n  };\n}\n\nfunction parse(input: string): ParsedSubmittedInput {\n  try {\n    const cConsumer = consumer.initialize(input);\n    // custom parser for createLobby\n    if (cConsumer.prefix() === 'createLobby') {\n      return parseSubmitTurn(cConsumer);\n    } else {\n      const parsed = myParser.start(input);\n      return { input: parsed.command, ...parsed.args } as any;\n    }\n  } catch (e) {\n    console.log(e, 'Parsing error');\n    return { input: 'invalidString' };\n  }\n}\n\n")),(0,r.kt)("h3",{id:"supported-characters"},"Supported characters"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"PaimaParser")," grammar supports UTF8, but generally has the following reserved characters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*")," See ",(0,r.kt)("a",{parentName:"li",href:"/home/read-write-L2-state/parallelism"},"parallelism")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@")," Implicitly use the address that submitted the wallet for ",(0,r.kt)("a",{parentName:"li",href:"/home/read-write-L2-state/parallelism"},"parallelism"),". That is, for parallelism purposes, ",(0,r.kt)("inlineCode",{parentName:"li"},"@x|a")," is equivalent to ",(0,r.kt)("inlineCode",{parentName:"li"},"x|*wallet|a"),", but no actual modifications is done to the onchain format"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"?")," Optional entry"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"|")," , ",(0,r.kt)("inlineCode",{parentName:"li"},"=")," Used to define the grammar"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"-")," Used for PaimaParser array notation"),(0,r.kt)("li",{parentName:"ul"},"ASCII 0x02 and 0x03. Use for ",(0,r.kt)("a",{parentName:"li",href:"/home/read-write-L2-state/batched-mode"},"batched-mode"))),(0,r.kt)("h2",{id:"concise-builder"},"Concise Builder"),(0,r.kt)("p",null,"Writing data is much simpler"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { builder } from 'paima-engine/paima-concise';\nimport {\n  awaitBlock,\n  getActiveAddress,\n  PaimaMiddlewareErrorCode,\n  postConciseData,\n} from 'paima-sdk/paima-mw-core';\n\n\nconst conciseBuilder = builder.initialize();\n//createdLobby = c|numOfRounds|isPractice?\nconciseBuilder.setPrefix('c');\nconciseBuilder.addValues([\n  { value: numberOfRounds.toString(10) },\n  { value: isPractice ? 'T' : '' },\n]);\n\nconst response = await postConciseData(\n  conciseBuilder.build(),\n  errorFxn // See other section in the documentation on error handling\n);\nif (!response.success) return response;\n\n// wait for the block to appear on-chain and do any error handling\n// ex: if state changed between when the user made a tx and the tx getting included in a block\nawait awaitBlock(response.blockHeight);\n")))}c.isMDXComponent=!0}}]);