"use strict";(self.webpackChunkpaima_engine_docs=self.webpackChunkpaima_engine_docs||[]).push([[3714],{1900:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var i=t(5893),r=t(1151);const s={},a="Dynamic primitives",o={id:"home/react-to-events/primitive-catalogue/evm/dynamic-primitives",title:"Dynamic primitives",description:"This primitive allows registering new extensions in runtime, without changing",source:"@site/docs/home/300-react-to-events/2-primitive-catalogue/10-evm/5-dynamic-primitives.md",sourceDirName:"home/300-react-to-events/2-primitive-catalogue/10-evm",slug:"/home/react-to-events/primitive-catalogue/evm/dynamic-primitives",permalink:"/home/react-to-events/primitive-catalogue/evm/dynamic-primitives",draft:!1,unlisted:!1,editUrl:"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/300-react-to-events/2-primitive-catalogue/10-evm/5-dynamic-primitives.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ERC6551 Primitives",permalink:"/home/react-to-events/primitive-catalogue/evm/ERC6551"},next:{title:"ERC1155 Primitives",permalink:"/home/react-to-events/primitive-catalogue/evm/ERC1155"}},c={},d=[{value:"Configuration",id:"configuration",level:2},{value:"ERC721 example",id:"erc721-example",level:3},{value:"Meaning",id:"meaning",level:3},{value:"Static configuration",id:"static-configuration",level:4},{value:"Dynamic configuration",id:"dynamic-configuration",level:4},{value:"Factory contracts",id:"factory-contracts",level:3},{value:"Utility functions",id:"utility-functions",level:2},{value:"Performance implications",id:"performance-implications",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"dynamic-primitives",children:"Dynamic primitives"}),"\n",(0,i.jsx)(n.p,{children:"This primitive allows registering new extensions in runtime, without changing\nthe configuration files. These are triggered by a generic smart contract event.\nA use-case for this would be a factory contract."}),"\n",(0,i.jsx)(n.p,{children:"Currently the dynamic extensions can be one of:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"ERC721",children:"ERC721"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"Generic",children:"Generic"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(n.h3,{id:"erc721-example",children:"ERC721 example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# extensions.yaml\nextensions:\n  - name: "Dynamic erc721"\n    type: "dynamic-primitive"\n    startBlockHeight: 100 \n    contractAddress: "0x5FbDB2315678afecb367f032d93F642f64180aa3"\n    eventSignature: "ERC721Created(address)"\n    abiPath: "./FactoryERC721.json"\n    targetConfig:\n      type: "erc721"\n      scheduledPrefix: "nft"\n      burnScheduledPrefix: "nftburn"\n    dynamicFields:\n      contractAddress: nftAddress\n'})}),"\n",(0,i.jsx)(n.h3,{id:"meaning",children:"Meaning"}),"\n",(0,i.jsx)(n.p,{children:"There are two type of fields in this configuration. The top level fields are\nused for the extension that have the role of monitoring the network for the\ntrigger event. These are the following:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"contractAdress"})," is the address of the smart contract that will emit the event that will trigger the erc721 primitive creation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"abiPath"}),", specifying a path to a .json file describing the compiled contract\n\u2013 the only field required in this file is the ",(0,i.jsx)(n.code,{children:"abi"})," field in the top-level\nobject;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"eventSignature"}),", specifying the signature of the event consisting only of the event name followed by parameter types (without names) in order, enclosed in parentheses and separated by commas."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The nested fields instead are used to construct the configuration for the\ndynamically generated extensions. It's divided into a static part, which is in\n",(0,i.jsx)(n.code,{children:"targetConfig"}),". And a dynamic part which is in ",(0,i.jsx)(n.code,{children:"dynamicFields"}),". Dynamic in this\ncontext means that it depends on the data included on the emitted event."]}),"\n",(0,i.jsx)(n.h4,{id:"static-configuration",children:"Static configuration"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"scheduledPrefix"})," is the prefix used for the events emitted by the dynamic\nextensions. This primitive won't emit events by itself."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["For the ",(0,i.jsx)(n.a,{href:"erc721",children:"erc721"})," case, there is also ",(0,i.jsx)(n.code,{children:"burnScheduledPrefix"}),", for which\nthe comment above also applies."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["For the ",(0,i.jsx)(n.a,{href:"Generic",children:"generic"})," primitive the ",(0,i.jsx)(n.code,{children:"targetConfig"})," field would look like\nthis instead:"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'targetConfig:\n  type: "generic"\n  abiPath: "./abis/MyCustomContract.json"\n  eventSignature: "MyEvent(address,uint256)"\n  scheduledPrefix: "cst"\n'})}),"\n",(0,i.jsx)(n.h4,{id:"dynamic-configuration",children:"Dynamic configuration"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"contractAddress"})," has the name of the parameter in the emitted event that\ncontains the address for the new primitive."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"factory-contracts",children:"Factory contracts"}),"\n",(0,i.jsx)(n.p,{children:"Solidity has no standardized way to create a factory contract. Instead, it's up\nto you to create your own factory contract whatever way works best, and to emit\nevents that trigger the dynamic primitive inside it.  The example configuration\nassumes that the event (such as in your factory contract) has the following\nsignature:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"// note: the name of the argument (nftAddress) has to match the name specified in dynamicFields\nevent ERC721Created(address indexed nftAddress);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Which could be part of the following implementation."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";\nimport {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";\n\ncontract CustomERC721 is ERC721 {\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n}\n\ncontract FactoryERC721 {\n    event ERC721Created(address indexed nftAddress); // emitted when ERC721 token is deployed\n\n    /// @dev deploys an ERC721 token with given parameters\n    /// @return address deployed\n    function deployERC721(string memory _name, string memory symbol) public returns (address) {\n        CustomERC721 t = new CustomERC721(_name, symbol);\n        emit ERC721Created(address(t));\n        return address(t);\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"NOTE:"})," Extra parameters in the event will be ignored, and the position does not matter."]}),"\n",(0,i.jsx)(n.h2,{id:"utility-functions",children:"Utility functions"}),"\n",(0,i.jsxs)(n.p,{children:["Generated extensions have a ",(0,i.jsx)(n.em,{children:"name"}),", that is derived from the name of the trigger\nextension, and the order of the dynamic primitive. The following function can be\nused to generate this name."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export function generateDynamicPrimitiveName(parentName: string, id: number): string;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For example, the first dynamic primitive that gets created will have a name of\n",(0,i.jsx)(n.code,{children:"generateDynamicPrimitiveName(parentCdeName, 0)"}),", and so on. This name can be\nthen used as an argument to the other utility functions."]}),"\n",(0,i.jsxs)(n.p,{children:["There is also a public utility function to get the list of all of the\ndynamically generated extensions. The ",(0,i.jsx)(n.code,{children:"config"})," field has a JSON with the\nconcrete parameters for that particular extension. These are the ones that would\nbe ",(0,i.jsx)(n.a,{href:"../../funnel-types/configuration#extensions",children:"in the configuration file"})," if\nthe primitive was not dynamic. The only exception is the ",(0,i.jsx)(n.code,{children:"name"})," field, which is\ninstead provided as a separated field."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export async function getDynamicExtensions(\n  readonlyDBConn: Pool,\n  parent: string\n): Promise<{ name: string; config: string }[]>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There is also the following function, which can be used to get the parameters\nfor a specific primitive by name. This can be used to access the contract\naddress in the ",(0,i.jsx)(n.a,{href:"../../../read-write-L2-state/read-data#stf-function",children:"state transition\nfunction"}),", by first getting\nthe name from the ",(0,i.jsx)(n.code,{children:"inputData.extensionName"})," field."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export async function getDynamicExtensionByName(\n  readonlyDBConn: Pool,\n  name: string\n): Promise<{ contractAddress: string; startBlockHeight: number }[]>;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-implications",children:"Performance implications"}),"\n",(0,i.jsx)(n.p,{children:"During a typical execution, the steps are as follows:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Fetch all primitives for a block range concurrently (depending on ",(0,i.jsx)(n.code,{children:"funnelBlockGroupSize"})," or\n",(0,i.jsx)(n.code,{children:"presyncStepSize"}),")."]}),"\n",(0,i.jsx)(n.li,{children:"Construct the blocks from the fetched data to feed to the state machine."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"However, dynamic primitive can change the set of primitives the rollup monitors (and therefore change what has to be fetched for a given block range). Therefore, if there are dynamic primitives configured, funnels will instead"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Request all of the events for dynamic primitives and update the set of primitives tracked by the rollup"}),"\n",(0,i.jsx)(n.li,{children:"Fetch primitives (both the static ones and the new ones after the dynamic primitive update)"}),"\n",(0,i.jsx)(n.li,{children:"Send blocks to the state machine as before"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This extra step introduces a performance reduction (whose impact depends how long it takes to fetch data from the node your game is connecting to)"})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var i=t(7294);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);