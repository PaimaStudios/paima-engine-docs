"use strict";(self.webpackChunkpaima_engine_docs=self.webpackChunkpaima_engine_docs||[]).push([[4430],{9218:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var i=t(5893),s=t(1151);const a={},r="Cardano Primitives",o={id:"home/react-to-events/primitive-catalogue/cardano",title:"Cardano Primitives",description:"- Stake Delegation.",source:"@site/docs/home/300-react-to-events/2-primitive-catalogue/1000-cardano.md",sourceDirName:"home/300-react-to-events/2-primitive-catalogue",slug:"/home/react-to-events/primitive-catalogue/cardano",permalink:"/home/react-to-events/primitive-catalogue/cardano",draft:!1,unlisted:!1,editUrl:"https://github.com/PaimaStudios/paima-engine-docs/docs/home/300-react-to-events/2-primitive-catalogue/1000-cardano.md",tags:[],version:"current",sidebarPosition:1e3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Generic Primitives",permalink:"/home/react-to-events/primitive-catalogue/Generic"},next:{title:"Create your own Primitive",permalink:"/home/react-to-events/primitive-catalogue/create-your-own"}},l={},d=[{value:"Stake Delegation",id:"stake-delegation",level:2},{value:"Example",id:"example",level:3},{value:"Meaning",id:"meaning",level:3},{value:"Paima Concise format",id:"paima-concise-format",level:3},{value:"Utility functions",id:"utility-functions",level:3},{value:"Delayed asset",id:"delayed-asset",level:2},{value:"Example",id:"example-1",level:3},{value:"Meaning",id:"meaning-1",level:3},{value:"Utility functions",id:"utility-functions-1",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"cardano-primitives",children:"Cardano Primitives"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#stake-delegation",children:"Stake Delegation"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#delayed-asset",children:"Delayed asset"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"stake-delegation",children:"Stake Delegation"}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'extensions:\n  - name: "Cardano Stake Delegation"\n    type: cardano-stake-delegation\n    pools:\n      - "00000000000000000000000000000000000000000000000000000001"\n      - "00000000000000000000000000000000000000000000000000000002"\n    startSlot: 32815320\n    stopSlot: 32815924\n    scheduledPrefix: cd\n'})}),"\n",(0,i.jsx)(n.h3,{id:"meaning",children:"Meaning"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"startSlot"})," is required and means that only delegation events after that slot (exclusive) will be considered."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"stopSlot"})," is optional, and it stops the indexing at that point for that pool."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pools"})," is a list of pool credentials to keep track of."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"paima-concise-format",children:"Paima Concise format"}),"\n",(0,i.jsx)(n.p,{children:"The scheduled input for each event is of the following form."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"prefix|address|pool\n"})}),"\n",(0,i.jsx)(n.p,{children:"where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"prefix"})," is the ",(0,i.jsx)(n.code,{children:"scheduledPrefix"})," specified in the config file,"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"address"})," is the stake credential of the address in CBOR."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pool"})," if the event is a delegation event, this is the pool. If the staking key is deregistered, or delegated to a pool outside the indexed ones, this will be null."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"utility-functions",children:"Utility functions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"getCardanoAddressDelegation"})," can be used to get the current pool (if any). It\nmust be called with the stake credential of the address. The result of this call\nwill be ",(0,i.jsx)(n.code,{children:"null"})," if the address didn't delegate to any of the indexed pools.\nOtherwise, ",(0,i.jsx)(n.code,{children:"events"})," will be one of:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"User changed delegation this epoch:"})," A sorted array with two entries. First\nentry is their last delegation before the current epoch, and the 2nd entry is\nfor ",(0,i.jsx)(n.em,{children:"currentEpoch"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"User hasn't changed delegation this epoch:"})," An array with a single entry\nrepresenting the last delegation."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"User first-time delegation:"})," An array with a single entry representing when\nthey first delegated. Note that it's possible for ",(0,i.jsx)(n.code,{children:"epoch"})," to be ",(0,i.jsx)(n.code,{children:"currentEpoch"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For a particular entry in the array, ",(0,i.jsx)(n.code,{children:"pool"})," will be ",(0,i.jsx)(n.code,{children:"null"})," when: first, the\nstake is delegated to a pool in the configuration. Then the stake gets\nre-delegated to a non-indexed pool, or the stake key is deregistered."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export declare function getCardanoAddressDelegation(\n  readonlyDBConn: Pool,\n  address: string\n): Promise<{ events: { pool: string | null; epoch: number }[]; currentEpoch: number } | null>;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Example using cml:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const address = Address.from_bech32(addressBech32);\nconst stakingCred = address.staking_cred();\n\nlet credential: Buffer;\n\nif (stakingCred) {\n  credential = Buffer.from(stakingCred.to_bytes());\n}\n\ngetCardanoAddressDelegation(dbConn, walletAddress);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"delayed-asset",children:"Delayed asset"}),"\n",(0,i.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'extensions:\n  - name: "delayed-asset1"\n    type: cardano-delayed-asset\n    fingerprints:\n      - "asset1c43p68zwjezc7aaaaaaaaaaaaaaaaaaaaaaaaa"\n      - "asset1c43p68zwjezc7bbbbbbbbbbbbbbbbbbbbbbbbb"\n      - "asset1c43p68zwjezc7ccccccccccccccccccccccccc"\n    policyIds:\n      - "919d4c2c9455016289341b1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"\n      - "919d4c2c9455016289341b1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"\n    startSlot: 22505578\n    stopSlot: 32815924\n'})}),"\n",(0,i.jsx)(n.h3,{id:"meaning-1",children:"Meaning"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"startSlot"})," is required and means that only events after that slot (exclusive)\nwill be considered. This should be a slot that happened before the first\ntransaction involving the assets."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"stopSlot"})," is optional, and it stops the indexing at that point."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fingerprints"})," and ",(0,i.jsx)(n.code,{children:"policyIds"})," select the assets to be indexed. It's not\nnecessary to provide both."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fingerprints"})," takes the cip14 fingerprint in bech32, and indexes a single\nasset (per entry in the array)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"policyIds"})," will instead index all the assets in that policy."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"utility-functions-1",children:"Utility functions"}),"\n",(0,i.jsxs)(n.p,{children:["There are two functions that can be used to get the utxo entries for an address.\nDepending on whether the filtering is done by fingerprint or by policy id. Note\nthat this doesn't necessarily return one entry per utxo, since each entry is for\na single asset. This means there may be more than one entry in the array with\nthe same ",(0,i.jsx)(n.code,{children:"txId-outputIndex"})," pair. This can happen when filtering by policy id,\nbecause an output have more than one asset.  In that case, the ",(0,i.jsx)(n.code,{children:"assetName"})," can\nbe used to discriminate."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export interface CardanoAssetUtxo {\n  txId: string;\n  outputIndex: number;\n  amount: string;\n  policyId: string;\n  assetName: string;\n}\n\nexport declare function getCardanoAssetUtxosByFingerprint(\n  readonlyDBConn: Pool,\n  address: string,\n  cip14Fingerprint: string\n): Promise<CardanoAssetUtxo[]>;\n\n\nexport declare function getCardanoAssetUtxosByPolicyId(\n  readonlyDBConn: Pool,\n  address: string,\n  policyId: string\n): Promise<CardanoAssetUtxo[]>;\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>r});var i=t(7294);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);