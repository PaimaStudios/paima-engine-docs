"use strict";(self.webpackChunkpaima_engine_docs=self.webpackChunkpaima_engine_docs||[]).push([[196],{2194:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var i=t(5893),a=t(1151);const r={},s="Dynamic ERC721",o={id:"home/react-to-events/primitive-catalogue/evm/dynamic-erc721",title:"Dynamic ERC721",description:"This primitive allows registering new ERC721 extensions in runtime,",source:"@site/docs/home/300-react-to-events/2-primitive-catalogue/10-evm/5-dynamic-erc721.md",sourceDirName:"home/300-react-to-events/2-primitive-catalogue/10-evm",slug:"/home/react-to-events/primitive-catalogue/evm/dynamic-erc721",permalink:"/ja/home/react-to-events/primitive-catalogue/evm/dynamic-erc721",draft:!1,unlisted:!1,editUrl:"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/300-react-to-events/2-primitive-catalogue/10-evm/5-dynamic-erc721.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ERC6551 Primitives",permalink:"/ja/home/react-to-events/primitive-catalogue/evm/ERC6551"},next:{title:"Dynamic primitives",permalink:"/ja/home/react-to-events/primitive-catalogue/evm/dynamic-primitives"}},c={},d=[{value:"Configuration",id:"configuration",level:2},{value:"Meaning",id:"meaning",level:3},{value:"Static configuration",id:"static-configuration",level:4},{value:"Dynamic configuration",id:"dynamic-configuration",level:4},{value:"Utility functions",id:"utility-functions",level:2},{value:"Performance implications",id:"performance-implications",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"dynamic-erc721",children:"Dynamic ERC721"}),"\n",(0,i.jsxs)(n.p,{children:["This primitive allows registering new ",(0,i.jsx)(n.a,{href:"ERC721",children:"ERC721"})," extensions in runtime,\ntriggered by a generic smart contract event. This works by having a smart\ncontract that has an event that acts as a ",(0,i.jsx)(n.em,{children:"trigger"})," to the engine, and the\nengine in response adds a new extension, without needing to change the\nconfiguration file. An use-case for this would be a factory contract, which\ntakes care of deploying new instances of the contract tracked by the newly\ngenerated primitive, and then emits and event to signal the engine to start\ntracking this through an event."]}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# extensions.yaml\nextensions:\n  - name: "Dynamic erc721"\n    type: "dynamic-primitive"\n    startBlockHeight: 100 \n    contractAddress: "0x5FbDB2315678afecb367f032d93F642f64180aa3"\n    eventSignature: "CustomEvent(address)"\n    abiPath: "./CustomEventEmitter.json"\n    targetConfig:\n      type: "erc721"\n      scheduledPrefix: "nft"\n      burnScheduledPrefix: "nftburn"\n    dynamicFields:\n      contractAddress: nftAddress\n'})}),"\n",(0,i.jsx)(n.h3,{id:"meaning",children:"Meaning"}),"\n",(0,i.jsx)(n.p,{children:"There are two type of fields in this configuration. The top level fields are\nused for the extension that have the role of monitoring the network for the\ntrigger event. These are the following:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"contractAdress"})," is the address of the smart contract that will emit the event that will trigger the erc721 primitive creation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"abiPath"}),", specifying a path to a .json file describing the compiled contract\n\u2013 the only field required in this file is the ",(0,i.jsx)(n.code,{children:"abi"})," field in the top-level\nobject;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"eventSignature"}),", specifying the signature of the event consisting only of the event name followed by parameter types (without names) in order, enclosed in parentheses and separated by commas."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The nested fields instead are used to construct the configurations for the\ndynamically generated extensions. It's divided into a static part, which is in\n",(0,i.jsx)(n.code,{children:"targetConfig"}),". And a dynamic part which is in ",(0,i.jsx)(n.code,{children:"dynamicFields"}),". Dynamic in this\ncontext means that it depends on the data included on the emitted event."]}),"\n",(0,i.jsx)(n.h4,{id:"static-configuration",children:"Static configuration"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"scheduledPrefix"})," and ",(0,i.jsx)(n.code,{children:"burnScheduledPrefix"})," are the prefixes used for the\nresulting ERC721 events. This primitive won't emit events by itself. See ",(0,i.jsx)(n.a,{href:"ERC721#meaning",children:"the\nERC721 section for details"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"dynamic-configuration",children:"Dynamic configuration"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"contractAddress"})," has the name of the field in the emitted event that contains\nthe address of the ERC721."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The example configuration assumes that the event has the following signature:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"event CustomEvent(address indexed nftAddress);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"utility-functions",children:"Utility functions"}),"\n",(0,i.jsxs)(n.p,{children:["Generated extensions have a ",(0,i.jsx)(n.em,{children:"name"}),", that is derived from the name of the trigger\nextension, and the order of the dynamic primitive. The following function can be\nused to generate this name."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export function generateDynamicPrimitiveName(parentName: string, id: number): string;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For example, the first dynamic primitive that gets created will have a name of\n",(0,i.jsx)(n.code,{children:"generateDynamicPrimitiveName(parentPrimitiveName, 0)"}),", and so on. This name can be\nthen used as an argument to the other utility functions."]}),"\n",(0,i.jsxs)(n.p,{children:["There is also a public utility function to get the list of all of the\ndynamically generated extensions. In this case the ",(0,i.jsx)(n.code,{children:"config"})," field is formatted\nas json. It can be used to extract, the contract address, for example."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export async function getDynamicExtensions(\n  readonlyDBConn: Pool,\n  parent: string\n): Promise<{ name: string; config: string }[]>;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-implications",children:"Performance implications"}),"\n",(0,i.jsxs)(n.p,{children:["Normally the funnels fetch all of the configured primitives concurrently in a\nrange of blocks configured by either the ",(0,i.jsx)(n.code,{children:"funnelBlockGroupSize"})," or\n",(0,i.jsx)(n.code,{children:"presyncStepSize"})," variables. But a dynamic primitive can change the set of\nextensions to fetch in the range, so if there are dynamic primitives configured,\nthe funnels will instead ",(0,i.jsx)(n.em,{children:"first"}),"  request all of the events for these, update\nthe set of extensions, and afterwards request the data for the resulting set\nconcurrently. This implies a small reduction of concurrency for the funnels."]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>s});var i=t(7294);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);