"use strict";(self.webpackChunkpaima_engine_docs=self.webpackChunkpaima_engine_docs||[]).push([[1685],{1288:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var i=n(5893),a=n(1151);const s={title:"prc-3\uff1aPaima Inverse Projection Interface",description:"Interface for inverse projection of game state into NFTs in other chains",author:"sebastiengllmt, matejos (@matejos)",status:"Draft",created:new Date("2024-03-03T00:00:00.000Z")},r=void 0,o={id:"home/PRCs/prc-3",title:"prc-3\uff1aPaima Inverse Projection Interface",description:"Interface for inverse projection of game state into NFTs in other chains",source:"@site/docs/home/20000-PRCs/prc-3.md",sourceDirName:"home/20000-PRCs",slug:"/home/PRCs/prc-3",permalink:"/ja/home/PRCs/prc-3",draft:!1,unlisted:!1,editUrl:"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/20000-PRCs/prc-3.md",tags:[],version:"current",frontMatter:{title:"prc-3\uff1aPaima Inverse Projection Interface",description:"Interface for inverse projection of game state into NFTs in other chains",author:"sebastiengllmt, matejos (@matejos)",status:"Draft",created:"2024-03-03T00:00:00.000Z"},sidebar:"tutorialSidebar",previous:{title:"prc-2\uff1aPaima Hololocker Interface",permalink:"/ja/home/PRCs/prc-2"},next:{title:"prc-5\uff1aPaima Inverse Projection Interface for ERC1155",permalink:"/ja/home/PRCs/prc-5"}},d={},l=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Specification",id:"specification",level:2},{value:"Token Identifier",id:"token-identifier",level:3},{value:"1) App Initiated",id:"1-app-initiated",level:4},{value:"Avoiding partial initialization",id:"avoiding-partial-initialization",level:5},{value:"Endpoint error cases",id:"endpoint-error-cases",level:5},{value:"2) Base Layer Initiated",id:"2-base-layer-initiated",level:4},{value:"Endpoint error cases",id:"endpoint-error-cases-1",level:5},{value:"Mint validity",id:"mint-validity",level:3},{value:"Tracking invalid mints",id:"tracking-invalid-mints",level:4},{value:"Rationale",id:"rationale",level:2},{value:"Rationale App-layer",id:"rationale-app-layer",level:3},{value:"Rationale Base-layer",id:"rationale-base-layer",level:3},{value:"Reference Implementation",id:"reference-implementation",level:2},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Copyright",id:"copyright",level:2}];function c(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"abstract",children:"Abstract"}),"\n",(0,i.jsx)(t.p,{children:"Allowing tradability of game state directly on popular networks helps achieve a lot more composability and liquidity than would otherwise be possible. This standard helps define how to define NFTs in different chains without introducing centralization, lowered security or wait times for finality."}),"\n",(0,i.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,i.jsx)(t.p,{children:"Many games, due to being data and computation heavy applications, run on sidechains, L2s and appchains as opposed to popular L1 blockchains. This is problematic because liquidity for trading assets live primarily on the L1s (different environments). A common solution to this problem is building an NFT bridge, but bridges have a bad reputation, often require a long delay (especially for optimistic bridges which often require 1 week), and bridging also makes upgrading the game harder as any update to the game state may now also require you to update the data associated with all the bridged state (ex: adding a new field for monsters in the game would require you to introduce this new field to all bridged assets)."}),"\n",(0,i.jsx)(t.p,{children:"Instead of bridging NFTs, this standard allows minting NFTs on more popular chains that acts as a pointing to game state. This allows keeping the game as the source of truth for game state."}),"\n",(0,i.jsx)(t.h2,{id:"specification",children:"Specification"}),"\n",(0,i.jsxs)(t.p,{children:["Every PRC-3 compliant contract must implement the ",(0,i.jsx)(t.code,{children:"IInverseProjectedNft"})," interface:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-solidity",children:"/// @dev An interface exposing the `tokenURI` function from IERC721Metadata.\ninterface ITokenUri {\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n/// @dev A standard ERC721 that can be burned and has a special tokenURI function accepting a custom base URI.\ninterface IInverseProjectedNft is IERC4906, IERC721Metadata {\n    /// @dev Emitted when `baseExtension` is updated from `oldBaseExtension` to `newBaseExtension`.\n    event SetBaseExtension(string oldBaseExtension, string newBaseExtension);\n\n    /// @dev Emitted when `baseUri` is updated from `oldUri` to `newUri`.\n    event SetBaseURI(string oldUri, string newUri);\n\n    /// @dev Burns token of ID `_tokenId`. Callable only by the owner of the specified token.\n    /// Reverts if `_tokenId` is not existing.\n    function burn(uint256 _tokenId) external;\n\n    /// @dev Sets `_URI` as the `baseURI` of the NFT.\n    /// Callable only by the contract owner.\n    /// Emits the `SetBaseURI` event.\n    function setBaseURI(string memory _URI) external;\n\n    /// @dev Sets `_newBaseExtension` as the `baseExtension` of the NFT.\n    /// Callable only by the contract owner.\n    function setBaseExtension(string memory _newBaseExtension) external;\n\n    /// @dev Returns the token URI of specified `tokenId` using a custom base URI.\n    function tokenURI(\n        uint256 tokenId,\n        string memory customBaseUri\n    ) external view returns (string memory);\n\n    /// @dev Returns the token URI of specified `tokenId` using a call to contract implementing `ITokenUri`.\n    function tokenURI(\n        uint256 tokenId,\n        ITokenUri customUriInterface\n    ) external view returns (string memory);\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"With the following baseURI:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"https://${rpcBase}/inverseProjection/${standard}/${purpose}/\n"})}),"\n",(0,i.jsx)(t.p,{children:"Where"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"rpcBase"})," is the URI for the RPC"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"standard"})," is for the specific PRC used to define the the format of this endpoint (ex: ",(0,i.jsx)(t.code,{children:"prc3"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"purpose"})," is a app-dependent string to describe what the NFT is for (ex: ",(0,i.jsx)(t.code,{children:"monsters"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["An example of such a ",(0,i.jsx)(t.code,{children:"baseURI"})," is ",(0,i.jsx)(t.code,{children:"https://rpc.mygame.com/inverseProjection/prc3/monsters/"})]}),"\n",(0,i.jsx)(t.h3,{id:"token-identifier",children:"Token Identifier"}),"\n",(0,i.jsxs)(t.p,{children:["Token identifiers MUST start with a ",(0,i.jsx)(t.code,{children:"chainIdentifier"}),": a unique ID for the chain following ",(0,i.jsx)(t.a,{href:"https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md",children:"caip-2"}),". For example, ",(0,i.jsx)(t.code,{children:"eip155:1"})," for Ethereum Mainnet (resulting in ",(0,i.jsx)(t.code,{children:"https://rpc.mygame.com/inverseProjection/prc3/monsters/eip155:1/"})," for our previous example)."]}),"\n",(0,i.jsx)(t.p,{children:"There are two possible ways to define the token identifier with different tradeoffs."}),"\n",(0,i.jsx)(t.h4,{id:"1-app-initiated",children:"1) App Initiated"}),"\n",(0,i.jsxs)(t.p,{children:["In this case, the user first initiates the projection on the app layer by specifying the chain ID they want to project data to as well as the address they will mint with. The game then provides the user with a unique ",(0,i.jsx)(t.code,{children:"userTokenId"}),", and the identifier will be ",(0,i.jsx)(t.code,{children:"${chainIdentifier}/${address}/${userTokenId}.json"})," where ",(0,i.jsx)(t.code,{children:"userTokenId"})," is 1-indexed."]}),"\n",(0,i.jsxs)(t.p,{children:["It will be up to the smart contract on the base layer to ensure the combination of ",(0,i.jsx)(t.code,{children:"<address, userTokenId>"})," is unique across all mints. We RECOMMEND setting ",(0,i.jsx)(t.code,{children:"userTokenId"})," to be an address-specific counter increasing in value starting from 1 to implement this."]}),"\n",(0,i.jsx)(t.mermaid,{value:"sequenceDiagram\n    actor Buyer\n    participant L1\n    actor Seller\n    participant Game\n    Seller->>Game: Request to mint NFT on <chainId, address>\n    Game->>Seller: Unique userTokenId\n    destroy Seller\n    Seller->>L1: Mint NFT to chainId <br> using address<br>\n    activate L1\n    L1->>Game: Paima Primitive detects NFT creation\n    Game->>Game: detects address, chainId and userTokenId match\n    L1->>Game: tokenURI\n    Game->>L1: Asset state in the game\n    Buyer->>L1: Buys NFT on market\n    Buyer->>L1: Burn NFT\n    deactivate L1\n    L1->>Game: Paima Primitive detects burn\n    Game->>Game: Give asset to buyer in-game"}),"\n",(0,i.jsx)(t.p,{children:"This case uses the following extension to the base interface"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-solidity",children:'/// @dev A Paima Inverse Projection NFT where initialization is handled by the app-layer.\n/// A standard ERC721 that can be freely minted and stores an unique <minter, userTokenId> pair (used in tokenURI) when minted.\ninterface IInverseAppProjectedNft is IInverseProjectedNft {\n    /// @dev Emitted when the globally-enforced tokenId in combination with an unique <minter, userTokenId> pair is minted.\n    event Minted(uint256 indexed tokenId, address indexed minter, uint256 indexed userTokenId);\n\n    /// @dev Mints a new token to address `_to`\n    /// Increases the `totalSupply` and `currentTokenId`.\n    /// Reverts if `_to` is a zero address or if it refers to smart contract but does not implement IERC721Receiver-onERC721Received.\n    /// Emits the `Minted` event.\n    /// @param _to where to send the NFT to\n    /// @param _verificationData any additional data to verify the validity of the mint\n    function mint(address _to, bytes memory _verificationData) external returns (uint256);\n\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///      except this function just sets data to "".\n    function mint(address _to) external returns (uint256);\n\n    /// @notice Returns the last nonce used (or 0 if the user has never minted)\n    /// @dev Useful if you need to either needs to\n    ///      1. Check if the nonce matches the expected value, or if more NFTs need to be minted\n    ///      2. Use a nonce algorithm where the next nonce depends on the current nonce\n    function currentNonce(address seller) external view returns (uint256);\n}\n'})}),"\n",(0,i.jsx)(t.h5,{id:"avoiding-partial-initialization",children:"Avoiding partial initialization"}),"\n",(0,i.jsx)(t.p,{children:"Additionally, apps SHOULD ask the user to sign all transactions first before actually submitting them to the network. This avoids a situation where the user makes a transaction in the game layer, but then rejects (or never signs) the transaction in the base layer (this isn't an invalid state as they can always mint the tx in the base layer later to continue where they left off, but it's poor UX)."}),"\n",(0,i.jsx)(t.p,{children:"In cases where this is not possible, the game CAN consider burn events for NFTs that were never initiated on the app layer as already handled, but care needs to be taken for burn events that are out of sync"}),"\n",(0,i.jsx)(t.mermaid,{value:"sequenceDiagram\n    actor User\n    participant L1\n    participant Game\n\n    User->>L1: Mint userTokenId 1\n    activate L1\n    L1->>Game: Paima Primitive detects NFT 1 creation\n    deactivate L1\n    User->>L1: Mint userTokenId 2\n    activate L1\n    L1->>Game: Paima Primitive detects NFT 2 creation\n    deactivate L1\n    User->>L1: Burn userTokenId 2\n    activate L1\n    L1->>Game: Paima Primitive detects NFT 2 burn\n    Note over L1,Game: Note NFT #35;1 was never burn or initiated\n    deactivate L1"}),"\n",(0,i.jsx)(t.h5,{id:"endpoint-error-cases",children:"Endpoint error cases"}),"\n",(0,i.jsx)(t.p,{children:"There are 2 error-cases to handle:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Querying a ",(0,i.jsx)(t.code,{children:"userTokenId"})," that has not yet been seen by the game node. This should not happen under normal use, but may happen if a user mints more times on the base layer without making any equivalent transaction in the app layer. This should return a ",(0,i.jsx)(t.code,{children:"404 error"})," (to avoid NFT marketplaces caching dummy data)"]}),"\n",(0,i.jsxs)(t.li,{children:["Querying a ",(0,i.jsx)(t.code,{children:"userTokenId"})," that is marked as invalid for this variation of the game. See ",(0,i.jsx)(t.a,{href:"#mint-validity",children:"this section"})]}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"2-base-layer-initiated",children:"2) Base Layer Initiated"}),"\n",(0,i.jsxs)(t.p,{children:["In this case, the user first initiates the projection on the base layer by simply minting the NFT specifying data as needed in the ",(0,i.jsx)(t.code,{children:"initialData"}),". The ",(0,i.jsx)(t.code,{children:"tokenId"})," from the smart contract will act as the ",(0,i.jsx)(t.code,{children:"identifier"})," (",(0,i.jsx)(t.code,{children:"${chainIdentifier}/${tokenId}.json"}),") where ",(0,i.jsx)(t.code,{children:"tokenId"})," is 1-indexed."]}),"\n",(0,i.jsx)(t.mermaid,{value:"sequenceDiagram\n    actor Buyer\n    participant L1\n    actor Seller\n    participant Game\n    destroy Seller\n    Seller->>L1: Mint NFT to chainId <br> using address\n    activate L1\n    L1->>Game: Paima Primitive detects NFT creation\n    L1->>Game: tokenURI\n    Game->>L1: Asset state in the game\n    Buyer->>L1: Buys NFT on market\n    Buyer->>L1: Burn NFT\n    deactivate L1\n    L1->>Game: Paima Primitive detects burn\n    Game->>Game: Give asset to buyer in-game"}),"\n",(0,i.jsx)(t.p,{children:"This case uses the following extension to the base interface"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-solidity",children:"/// @dev A Paima Inverse Projection NFT where initialization is handled by the base-layer.\n/// A standard ERC721 that accepts calldata in the mint function for any initialization data needed in a Paima dApp.\ninterface IInverseBaseProjectedNft is IInverseProjectedNft {\n    /// @dev Emitted when the globally-enforced tokenId is minted, with `initialData` provided in the `mint` function parameters.\n    event Minted(uint256 indexed tokenId, string initialData);\n\n    /// @dev Mints a new token to address `_to`, passing `initialData` to be emitted in the event.\n    /// Increases the `totalSupply` and `currentTokenId`.\n    /// Reverts if `_to` is a zero address or if it refers to smart contract but does not implement IERC721Receiver-onERC721Received.\n    /// Emits the `Minted` event.\n    function mint(address _to, string calldata initialData) external returns (uint256);\n}\n"})}),"\n",(0,i.jsx)(t.h5,{id:"endpoint-error-cases-1",children:"Endpoint error cases"}),"\n",(0,i.jsx)(t.p,{children:"There are 2 error-cases to handle:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Querying a ",(0,i.jsx)(t.code,{children:"tokenID"})," that has not yet been seen by the game node. This will happen because there is always a delay between something happening on the base layer and the Paima node detecting it. This should return a ",(0,i.jsx)(t.code,{children:"404 error"})," instead of dummy data (to avoid NFT marketplaces caching dummy data)"]}),"\n",(0,i.jsxs)(t.li,{children:["Invalid ",(0,i.jsx)(t.code,{children:"initialData"})," provided (the definition of invalid is app-specific). See ",(0,i.jsx)(t.a,{href:"#mint-validity",children:"this section"})]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"mint-validity",children:"Mint validity"}),"\n",(0,i.jsx)(t.p,{children:'Background: collection offers are a common feature in NFT marketplaces allowing users to place a price on any asset in the collection instead of having to pick an individual NFT. Similarly, another feature known as "sweeping the floor" buys all NFTs in a collection starting with the lowest value.'}),"\n",(0,i.jsx)(t.p,{children:'These two features need extra work to work for PRC-3 assets. This is because some mints may be "invalid", and we want to avoid users buying / sweeping invalid assets without realizing. Invalid assets should not be blocked entirely (because they may be valid for a different variation of the game), but users should be able to place a buy/sweep order according to the validity of a specific version of the game.'}),"\n",(0,i.jsx)(t.p,{children:"To enable these features to work, all NFTs in the collection SHOULD contain the following attribute:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:'attributes: [{ "trait_type": "validity", "value": "valid" }]'})," for valid mints"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:'attributes: [{ "trait_type": "validity", "value": "invalid" }]'})," for invalid mints"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This will help users make trait-based collection offers for the NFTs."}),"\n",(0,i.jsx)(t.p,{children:"Note that there are actually 4-cases for the state of NFT attributes:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"An HTTP 404 error (because the RPC used is down or because the mint hasn't been initialized yet)"}),"\n",(0,i.jsx)(t.li,{children:"An HTTP 404 error (because the mint is considered invalid. This may happen if the game node does not store failed transactions)"}),"\n",(0,i.jsxs)(t.li,{children:["A valid response (",(0,i.jsx)(t.code,{children:'value: "valid"'}),")"]}),"\n",(0,i.jsxs)(t.li,{children:["An invalid response (",(0,i.jsx)(t.code,{children:'value: "invalid"'}),")"]}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"tracking-invalid-mints",children:"Tracking invalid mints"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),": regardless of which layer does the initialization, the state transition to process the inverse projection should ",(0,i.jsx)(t.em,{children:"never"})," fail for any reason other than signature mismatch. If the data received to initiate the projection is invalid, the game should simply mark the data itself as invalid and still increment the user's value for ",(0,i.jsx)(t.code,{children:"userTokenId"}),". This is because even though this inverse projection may be invalid for ",(0,i.jsx)(t.em,{children:"this version"})," of the game, there may be another version of the game run by players where this state transition ",(0,i.jsx)(t.em,{children:"is"})," valid. Failure to do this will result in different ",(0,i.jsx)(t.code,{children:"userTokenId"})," for the same valid mint on 2 variants of the game (breaking interoperability)."]}),"\n",(0,i.jsx)(t.mermaid,{value:"sequenceDiagram\n    actor User\n    participant Game Contract\n    participant Game #35;1\n    participant Game #35;2\n    alt variant-specific mint\n        User->>Game Contract: Initiate inverse projection\n        activate Game Contract\n        Game Contract->>Game #35;1: react to event\n        Game #35;1->>Game #35;1: invalid\n        Note right of Game #35;1: userTokenId = 1\n        Game Contract->>Game #35;2: react to event\n        Game #35;2->>Game #35;2: valid\n        Note right of Game #35;2: userTokenId + 1 = 2\n    end\n    alt both game mint\n        User->>Game Contract: Initiate inverse projection\n        activate Game Contract\n        Game Contract->>Game #35;1: react to event\n        Game #35;1->>Game #35;1: valid\n        Note right of Game #35;1: userTokenId + 1 = 2\n        Game Contract->>Game #35;2: react to event\n        Game #35;2->>Game #35;2: valid\n        Note right of Game #35;2: userTokenId + 1 = 3\n    end\n    Note right of User: User sees different userTokenId<br />despite mint being valid in both games\n    deactivate Game Contract"}),"\n",(0,i.jsx)(t.h2,{id:"rationale",children:"Rationale"}),"\n",(0,i.jsx)(t.p,{children:"Instead of holding the data for the NFT in IPFS or other immutable storage, the NFT instead corresponds to the RPC call that needs to be made to the game node to fetch the data this NFT encodes (or contract call to be made to where to get that data)."}),"\n",(0,i.jsxs)(t.p,{children:["Note that for this standard to be secure, you cannot mint these NFTs on arbitrary chains - rather, it has to be on a chain that the game is either actively monitoring (or occasionally receives updates about through a bridge or other mechanism). To avoid contracts deployed on one chain pretending to be NFTs from another, the Solidity contract itself should enforce the ",(0,i.jsx)(t.code,{children:"chainIdentifier"})," (as opposed to being part of the baseURI)."]}),"\n",(0,i.jsx)(t.p,{children:"Key differences from ERC721:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"mint"})," can be called by anybody at anytime (infinite supply).","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["If the projection is initiated by the base layer, it also needs to contain the ",(0,i.jsx)(t.code,{children:"initialData"})," to specify what is being projected."]}),"\n",(0,i.jsxs)(t.li,{children:["If the projection is initiated by the app layer, it can pass optionally pass in ",(0,i.jsx)(t.code,{children:"_verificationData"})," if the app layer state is verifiable."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"tokenURI"})," from ",(0,i.jsx)(t.code,{children:"IERC721"})," will lookup from default RPC for the game to ensure data is properly visible from standard marketplaces like OpenSea. To avoid this being a point of centralization, two variants of the ",(0,i.jsx)(t.code,{children:"tokenURI"})," function are provided:","\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["One that accepts a ",(0,i.jsx)(t.code,{children:"customBaseUri"})," for marketplaces / users to provide their own RPC if they wish"]}),"\n",(0,i.jsxs)(t.li,{children:["One that accepts any contracts that implements a ",(0,i.jsx)(t.code,{children:"ITokenUri"})," interface in-case the data comes from an onchain source."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["The contract uses ",(0,i.jsx)(t.a,{href:"https://eips.ethereum.org/EIPS/eip-4906",children:"ERC-4906"})," to force marketplaces to invalidate their cache. These functions are callable by anybody (not just the admin) so that if ever the game updates with new features (either user-initiated or by the original authors of the game), marketplaces will properly refetch the data."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"rationale-app-layer",children:"Rationale App-layer"}),"\n",(0,i.jsxs)(t.p,{children:["Having ",(0,i.jsx)(t.code,{children:"userTokenId"})," be a deterministic increasing value not only avoids double-mints (creating 2 NFTs pointing to the same app data), it also avoids any issues with failed transactions (if a tx on the base layer fails, just create a new tx)"]}),"\n",(0,i.jsx)(t.p,{children:"Upside:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"No need to wait for finality or bridge latency in the base layer for the game to detect the Paima Primitive and update the state machine to reflect the mint."}),"\n",(0,i.jsx)(t.li,{children:"Supports cases when the game state is verifiable (ex: if the game is a ZK rollup whose state is posted to the same base layer you can verify if the mint is valid according to the game state)"}),"\n",(0,i.jsx)(t.li,{children:"Easier to batch mint"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Downside:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Requires a transaction on the layer where the app is deployed (although usually this is a place where tx fees are cheap) compared to when initiated on the base-layer which does not require an explicit app-layer transaction."}),"\n",(0,i.jsx)(t.li,{children:"Extra work to coordinate submission of transactions on 2 chains at the same time"}),"\n",(0,i.jsx)(t.li,{children:"Requires extra logic in the Solidity smart contract to avoid double-mints (only 1 address can claim any minted data in the base layer and ensure the address can claim it only once) which increases tx fees."}),"\n",(0,i.jsx)(t.li,{children:"~175% the gas cost of the base-layer approach (130k ~ 175k gas)"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"rationale-base-layer",children:"Rationale Base-layer"}),"\n",(0,i.jsx)(t.p,{children:"Upside:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Lower gas cost because uniqueness is guaranteed by ",(0,i.jsx)(t.code,{children:"tokenId"})," (no need for extra data structures to avoid double-mints)"]}),"\n",(0,i.jsx)(t.li,{children:"Does not require any transaction on the app layer"}),"\n",(0,i.jsx)(t.li,{children:"57% the gas cost of the app-layer approach (75k ~ 100k gas)"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Downside:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Extra ",(0,i.jsx)(t.code,{children:"calldata"})," cost for ",(0,i.jsx)(t.code,{children:"initialData"})]}),"\n",(0,i.jsx)(t.li,{children:"Need to wait for finality on the base layer (+ any bridge latency if the layer is not natively monitored by the app)."}),"\n",(0,i.jsxs)(t.li,{children:["Mints may fail if the mint is no longer valid by the time the app learns about it (ex: passing ",(0,i.jsx)(t.code,{children:"initialData"})," to mint a monster the user no longer owns by the time the app sees the mint transaction)"]}),"\n",(0,i.jsx)(t.li,{children:"More complex game logic (ex: what happens if the user mints a monster and the mint transaction is seen when the monster is in a battle? You could decide to wait until the user has finished the battle to process the mint, but this adds extra complexity to your state machine)."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"reference-implementation",children:"Reference Implementation"}),"\n",(0,i.jsxs)(t.p,{children:["You can find all the contracts and interfaces in the Paima Engine codebase ",(0,i.jsx)(t.a,{href:"https://github.com/PaimaStudios/paima-engine/blob/master/packages/contracts/evm-contracts/contracts/token/",children:"here"})]}),"\n",(0,i.jsx)(t.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Honest RPC"}),": This standard relies on the default RPC being honestly operated. This is, however, not really a new trust assumption because this is a required assumption in nearly all dApps at the moment (including those like OpenSea where you have to trust them to be operating their website honestly). Just like somebody can run their own Ethereum fullnode to verify the data they see in an NFT marketplace, they can also sync fullnode for a Paima app and use their own RPC to fetch the state."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"App layer finality"}),": If the app layer can rollback, it can cause the data from the RPC call to change or become invalid entirely. NFT marketplaces may not update their cache to reflect these changes right away, but can be force-updated by anyone using ",(0,i.jsx)(t.a,{href:"https://eips.ethereum.org/EIPS/eip-4906",children:"ERC-4906"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"copyright",children:"Copyright"}),"\n",(0,i.jsxs)(t.p,{children:["Copyright and related rights waived via ",(0,i.jsx)(t.a,{href:"https://raw.githubusercontent.com/PaimaStudios/PRC/main/LICENSE.md",children:"CC0"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>r});var i=n(7294);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);