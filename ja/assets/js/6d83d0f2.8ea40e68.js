"use strict";(self.webpackChunkpaima_engine_docs=self.webpackChunkpaima_engine_docs||[]).push([[8900],{7063:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var a=r(5893),s=r(1151);const t={sidebar_position:1},i="Read and Write to L2 state",o={id:"home/read-write-L2-state/base-format",title:"Read and Write to L2 state",description:"To be a rollup, Paima state has to eventually be written to the L1. As a sovereign rollup, the way the data is stored is fairly simple (calling a contract function that simply emits its input as an event) and we provide a way to generate a grammar for this data.",source:"@site/docs/home/200-read-write-L2-state/1-base-format.md",sourceDirName:"home/200-read-write-L2-state",slug:"/home/read-write-L2-state/base-format",permalink:"/ja/home/read-write-L2-state/base-format",draft:!1,unlisted:!1,editUrl:"https://github.com/PaimaStudios/paima-engine-docs/docs/home/200-read-write-L2-state/1-base-format.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Paima Batcher",permalink:"/ja/home/setup/paima-bacher"},next:{title:"Sequential State Identifier",permalink:"/ja/home/read-write-L2-state/parallelism"}},d={},c=[{value:"Read data",id:"read-data",level:2},{value:"Defining a grammar",id:"defining-a-grammar",level:3},{value:"Manually parsing",id:"manually-parsing",level:3},{value:"Example usage",id:"example-usage",level:4},{value:"Supported characters",id:"supported-characters",level:3},{value:"Concise Builder",id:"concise-builder",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"read-and-write-to-l2-state",children:"Read and Write to L2 state"}),"\n",(0,a.jsxs)(n.p,{children:["To be a rollup, Paima state has to eventually be written to the L1. As a sovereign rollup, the way the data is stored is fairly simple (calling a contract function that simply emits its input as an event) and we provide a way to generate a ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Formal_grammar",children:"grammar"})," for this data."]}),"\n",(0,a.jsxs)(n.p,{children:["Paima has its own format for representing L2 data called Paima Concise that resembles a bar-separated string (ex: ",(0,a.jsx)(n.code,{children:"c|3|100|"}),"). This was chosen as"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"It is human-readable, which not only helps with coding & debugging, but also helps users verify the content of the string when signing from their wallet such as Metamask"}),"\n",(0,a.jsx)(n.li,{children:"It is easy to combine with many parsing tools (given the prevalence of CSV) and so it avoids having to write a lot of custom parers to Paima Concise in multiple programming languages & tools"}),"\n",(0,a.jsxs)(n.li,{children:["It is easy to combine with other formats if desired. For example, you could use ",(0,a.jsx)(n.a,{href:"https://protobuf.dev/",children:"protobuf"})," to encode one of the fields in the bar-separated string (although we recommend using PaimaParser defined below instead)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Paima comes with two classes to help generate these bar-separated strings"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// create the bar-separated string\nimport { builder } from '@paimas/sdk/concise';\n// parse the bar-separated string\nimport { consumer } from '@paima/sdk/concise';\n"})}),"\n",(0,a.jsx)(n.h2,{id:"read-data",children:"Read data"}),"\n",(0,a.jsx)(n.h3,{id:"defining-a-grammar",children:"Defining a grammar"}),"\n",(0,a.jsxs)(n.p,{children:["We allow defining more complex grammars on top of this notation using ",(0,a.jsx)(n.code,{children:"PaimaParser"}),". The process has two steps:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Define a base grammar (which Paima will then internally convert into ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form",children:"EBNF"})," form)"]}),"\n",(0,a.jsx)(n.li,{children:"Define how to parse tokens in this grammar (recursively defined)"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import type { ParserRecord } from '@paima/concise';\nimport { PaimaParser } from '@paima/sdk/concise';\n\n// First, define your grammar which Paima will turn into EBNF form internally\nconst myGrammar = `\ncreatedLobby        = c|numOfRounds|isPractice?\njoinedLobby         = j|*lobbyID\n`;\n\n// Setup the type definitions for the result of parsing\nexport interface CreatedLobbyInput {\n  input: 'createdLobby';\n  numOfRounds: number;\n  isPractice: boolean;\n}\nexport interface JoinedLobbyInput {\n  input: 'joinedLobby';\n  lobbyID: string;\n}\nexport interface InvalidInput {\n  input: 'invalidString';\n}\nexport type ParsedSubmittedInput =\n  | CreatedLobbyInput\n  | JoinedLobbyInput\n  | InvalidInput;\n\n\n// First, define how to parse the leaf tokens in this grammar\n// Note: objects keys here MUST match the names using in your grammar\n// ex: `numOfRounds` key here defines which function to use to parse the token defined in the grammar above\nconst createdLobby: ParserRecord<CreatedLobbyInput> = {\n  numOfRounds: PaimaParser.NumberParser(3, 1000),\n  isPractice: PaimaParser.TrueFalseParser(false),\n};\nconst joinedLobby: ParserRecord<JoinedLobbyInput> = {\n  lobbyID: PaimaParser.NCharsParser(12, 12),\n};\n\n// Define the top-level tokens\nconst parserCommands: Record<string, ParserRecord<ParsedSubmittedInput>> = {\n  createdLobby, // this means parse the key \"createLobby\" using the \"createLobby\" object defined above\n  joinedLobby\n};\n\nconst myParser = new PaimaParser(myGrammar, parserCommands);\n\nfunction parse(s: string): ParsedSubmittedInput {\n  try {\n    const parsed = myParser.start(s);\n    return { input: parsed.command, ...parsed.args } as any;\n  } catch (e) {\n    console.log(e, 'Parsing error');\n    return { input: 'invalidString' };\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"PaimaParser"})," comes with many of the common token parsing utility functions you need"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"ArrayParser(iter: { perItemParser: ParserCommandExec })"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"TrueFalseParser(defaultValue?: boolean)"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"DefaultRoundLength(blockTimeInSecs: number)"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"NumberParser(min?: number, max?: number)"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"NCharsParser(minChars: number, maxChars: number)"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"RegexParser(regex: RegExp)"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"HexParser()"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"WalletAddress()"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"EnumParser(values: readonly string[], transform?: (value: string) => string)"})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"manually-parsing",children:"Manually parsing"}),"\n",(0,a.jsx)(n.p,{children:"Although using a grammar is often the best way to go, you can also manually parse the data for use-cases where the encoding cannot be represented using the grammar system."}),"\n",(0,a.jsxs)(n.p,{children:["You can define your own parser as they satisfy the type ",(0,a.jsx)(n.code,{children:"ParserCommandExec"})," defined below"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"type ParserValues = string | boolean | number | null;\ntype ParserCommandExec = (keyName: string, input: string) => ParserValues | ParserValues[];\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If you want to define your own parse functions, we suggest the ",(0,a.jsx)(n.a,{href:"https://www.npmjs.com/package/parsimmon",children:"parsimmon"})," NPM package."]}),"\n",(0,a.jsx)(n.h4,{id:"example-usage",children:"Example usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import P from 'parsimmon';\nimport { consumer } from '@paima/sdk/concise';\n\nconst pRoundNumber = P.digits.map(Number).chain(n => {\n  if (n >= 1 && n <= 1000) return P.succeed(n);\n  else return P.fail(`Round Number must be above 0`);\n});\nconst pMaybeBool = P.string('T').or(P.string('F')).or(P.succeed(null));\n\nfunction parseSubmitTurn(c: ConciseConsumer): SubmittedTurnInput {\n  const roundNumber = tryParse(c.nextValue(), pRoundNumber);\n  const isPractice = tryParse(c.nextValue(), pMaybeBool);\n  return {\n    input: 'createLobby',\n    numOfRounds,\n    isPractice,\n  };\n}\n\nfunction parse(input: string): ParsedSubmittedInput {\n  try {\n    const cConsumer = consumer.initialize(input);\n    // custom parser for createLobby\n    if (cConsumer.prefix() === 'createLobby') {\n      return parseSubmitTurn(cConsumer);\n    } else {\n      const parsed = myParser.start(input);\n      return { input: parsed.command, ...parsed.args } as any;\n    }\n  } catch (e) {\n    console.log(e, 'Parsing error');\n    return { input: 'invalidString' };\n  }\n}\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"supported-characters",children:"Supported characters"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"PaimaParser"})," grammar supports UTF8, but generally has the following reserved characters:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"*"})," See ",(0,a.jsx)(n.a,{href:"/ja/home/read-write-L2-state/parallelism",children:"parallelism"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@"})," Implicitly use the address that submitted the wallet for ",(0,a.jsx)(n.a,{href:"/ja/home/read-write-L2-state/parallelism",children:"parallelism"}),". That is, for parallelism purposes, ",(0,a.jsx)(n.code,{children:"@x|a"})," is equivalent to ",(0,a.jsx)(n.code,{children:"x|*wallet|a"}),", but no actual modifications is done to the onchain format"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"?"})," Optional entry"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"|"})," , ",(0,a.jsx)(n.code,{children:"="})," Used to define the grammar"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"-"})," Used for PaimaParser array notation"]}),"\n",(0,a.jsxs)(n.li,{children:["ASCII 0x02 and 0x03. Use for ",(0,a.jsx)(n.a,{href:"/ja/home/read-write-L2-state/batched-mode",children:"batched-mode"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"concise-builder",children:"Concise Builder"}),"\n",(0,a.jsx)(n.p,{children:"Writing data is much simpler"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { builder } from '@paima/sdk/concise';\nimport {\n  awaitBlock,\n  getActiveAddress,\n  PaimaMiddlewareErrorCode,\n  postConciseData,\n} from '@paima/sdk/mw-core';\n\n\nconst conciseBuilder = builder.initialize();\n//createdLobby = c|numOfRounds|isPractice?\nconciseBuilder.setPrefix('c');\nconciseBuilder.addValues([\n  { value: numberOfRounds.toString(10) },\n  { value: isPractice ? 'T' : '' },\n]);\n\nconst response = await postConciseData(\n  conciseBuilder.build(),\n  errorFxn // See other section in the documentation on error handling\n);\nif (!response.success) return response;\n\n// wait for the block to appear on-chain and do any error handling\n// ex: if state changed between when the user made a tx and the tx getting included in a block\nawait awaitBlock(response.blockHeight);\n"})})]})}function m(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>o,a:()=>i});var a=r(7294);const s={},t=a.createContext(s);function i(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);