"use strict";(self.webpackChunkpaima_engine_docs=self.webpackChunkpaima_engine_docs||[]).push([[4105],{3381:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var t=n(5893),i=n(1151);const r={},s="Reading L2 Data",o={id:"home/state-machine/define-machine/read-data",title:"Reading L2 Data",description:"Creating the parser",source:"@site/docs/home/100-state-machine/100-define-machine/10-read-data.md",sourceDirName:"home/100-state-machine/100-define-machine",slug:"/home/state-machine/define-machine/read-data",permalink:"/ja/home/state-machine/define-machine/read-data",draft:!1,unlisted:!1,editUrl:"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-state-machine/100-define-machine/10-read-data.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Onchain Data Grammar",permalink:"/ja/home/state-machine/define-machine/base-format"},next:{title:"Sequential State Identifier",permalink:"/ja/home/state-machine/define-machine/parallelism"}},c={},d=[{value:"Creating the parser",id:"creating-the-parser",level:2},{value:"Calling the parser from your STF",id:"stf-function",level:2},{value:"Reading data from an external source",id:"reading-data-from-an-external-source",level:2},{value:"(Hardhat) Read Paima game input",id:"hardhat-read-paima-game-input",level:3},{value:"(Explorer) See historical game inputs",id:"explorer-see-historical-game-inputs",level:3}];function h(e){const a={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.h1,{id:"reading-l2-data",children:"Reading L2 Data"}),"\n",(0,t.jsx)(a.h2,{id:"creating-the-parser",children:"Creating the parser"}),"\n",(0,t.jsxs)(a.p,{children:["Now that you've defined you grammar in the ",(0,t.jsx)(a.a,{href:"/ja/home/state-machine/define-machine/base-format",children:"previous section"}),", you can generate your parse like this:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-typescript",children:"import { PaimaParser } from '@paima/sdk/concise';\n\nconst myParser = new PaimaParser(myGrammar, parserCommands);\n\nfunction parse(s: string): ParsedSubmittedInput {\n  try {\n    const parsed = myParser.start(s);\n    return { input: parsed.command, ...parsed.args } as any;\n  } catch (e) {\n    console.log(e, 'Parsing error');\n    return { input: 'invalidString' };\n  }\n}\n"})}),"\n",(0,t.jsx)(a.h2,{id:"stf-function",children:"Calling the parser from your STF"}),"\n",(0,t.jsxs)(a.p,{children:["Paima works by updating your state machine whenever happens onchain - the most common case being that somebody interacted with your Paima L2 contract. The set of actions your state machine can react to are called the ",(0,t.jsx)(a.a,{href:"/ja/home/state-machine/react-to-events/primitive-catalogue/introduction",children:"Paima Primitives"}),"."]}),"\n",(0,t.jsxs)(a.p,{children:["Your parser can then be used in the ",(0,t.jsx)(a.em,{children:"stf"})," (state transition function) of your application"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-typescript",children:"export default async function (\n  inputData: SubmittedChainData,\n  blockHeight: number,\n  randomnessGenerator: Prando,\n  dbConn: Pool\n): Promise<SQLUpdate[]> {\n  console.log(inputData, 'parsing input data');\n  const user = inputData.userAddress.toLowerCase();\n\n  // use your parser from the previous section\n  // highlight-next-line\n  const parsed = parse(inputData.inputData);\n\n  console.log(`Processing input string: ${inputData.inputData}`);\n  console.log(`Input string parsed as: ${parsed.input}`);\n\n  switch (parsed.input) {\n    // highlight-next-line\n    case 'createLobby':\n      // handle this input however you need (but needs to be deterministic)\n    default:\n      return [];\n  }\n}\n"})}),"\n",(0,t.jsx)(a.h2,{id:"reading-data-from-an-external-source",children:"Reading data from an external source"}),"\n",(0,t.jsx)(a.h3,{id:"hardhat-read-paima-game-input",children:"(Hardhat) Read Paima game input"}),"\n",(0,t.jsxs)(a.p,{children:["Paima comes with a Hardhat plugin as part of ",(0,t.jsx)(a.a,{href:"https://www.npmjs.com/package/@paima/evm-contracts",children:"@paima/evm-contracts"})," for this."]}),"\n",(0,t.jsxs)(a.p,{children:["To use it, make sure you have ",(0,t.jsx)(a.code,{children:"import @paima/evm-contracts/plugin"})," at the top of your ",(0,t.jsx)(a.code,{children:"hardhat.config.ts"})]}),"\n",(0,t.jsxs)(a.p,{children:["For reading inputs submitted to your L2 contract directly (instead of implicitly through another ",(0,t.jsx)(a.a,{href:"/ja/home/state-machine/react-to-events/primitive-catalogue/introduction",children:"Paima Primitive"}),"), you can run ",(0,t.jsx)(a.code,{children:"npx hardhat paima PaimaL2Contract:recentInputs"}),".\nThis command helps you see ",(0,t.jsx)(a.em,{children:"recent"})," inputs to your L2 contract (not the best tool for getting all historic interactions)."]}),"\n",(0,t.jsx)(a.h3,{id:"explorer-see-historical-game-inputs",children:"(Explorer) See historical game inputs"}),"\n",(0,t.jsxs)(a.p,{children:["You can, of course, also see all interactions with your smart contract on any blockchain explorer for the network you deployed to (recall: you can find your L2 contract address in anytime in ",(0,t.jsx)(a.code,{children:"./contracts/evm/ignition/deployments/chain-XXX/deployed_addresses.json"}),")"]})]})}function m(e={}){const{wrapper:a}={...(0,i.a)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},1151:(e,a,n)=>{n.d(a,{Z:()=>o,a:()=>s});var t=n(7294);const i={},r=t.createContext(i);function s(e){const a=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(r.Provider,{value:a},e.children)}}}]);