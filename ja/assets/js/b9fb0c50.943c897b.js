"use strict";(self.webpackChunkpaima_engine_docs=self.webpackChunkpaima_engine_docs||[]).push([[801],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),p=r,h=d["".concat(l,".").concat(p)]||d[p]||m[p]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},649:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:1},i="Scheduling Events and Timers",s={unversionedId:"home/react-to-events/scheduled-events",id:"home/react-to-events/scheduled-events",title:"Scheduling Events and Timers",description:"Games heavily rely on passive time to trigger events, such as limits on the length of a match or the duration of status effects. Paima supports these through a generic system called scheduledData that keeps track of which inputs (that conform to your app's grammar) to trigger at which block height (used instead of timestamps).",source:"@site/docs/home/3-react-to-events/1-scheduled-events.md",sourceDirName:"home/3-react-to-events",slug:"/home/react-to-events/scheduled-events",permalink:"/ja/home/react-to-events/scheduled-events",draft:!1,editUrl:"https://github.com/PaimaStudios/paima-engine-docs/docs/home/3-react-to-events/1-scheduled-events.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Auto-signing for apps",permalink:"/ja/home/read-write-L2-state/autosign"},next:{title:"Chain Data Extensions (CDEs)",permalink:"/ja/home/react-to-events/chain-data-extensions/introduction"}},l={},c=[{value:"1. Simple durations",id:"1-simple-durations",level:2},{value:"2. Synchronizing access to a shared state",id:"2-synchronizing-access-to-a-shared-state",level:2}],u={toc:c},d="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"scheduling-events-and-timers"},"Scheduling Events and Timers"),(0,r.kt)("p",null,"Games heavily rely on passive time to trigger events, such as limits on the length of a match or the duration of status effects. Paima supports these through a generic system called ",(0,r.kt)("inlineCode",{parentName:"p"},"scheduledData")," that keeps track of which inputs (that conform to your app's grammar) to trigger at which block height (used instead of timestamps)."),(0,r.kt)("p",null,"Paima will fetch, execute and commit the result of any scheduled data for a block BEFORE it considers any regular input inside the block."),(0,r.kt)("p",null,"There are three common usages of timers in Paima"),(0,r.kt)("h2",{id:"1-simple-durations"},"1. Simple durations"),(0,r.kt)("p",null,"There are two functions for scheduling events"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"createScheduledData(inputData: string, blockHeight: number): SQLUpdate")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"deleteScheduledData(inputData: string, blockHeight: number | null): SQLUpdate"))),(0,r.kt)("p",null,"Notably, ",(0,r.kt)("inlineCode",{parentName:"p"},"deleteScheduledData")," is very useful to cancel timers. For example, a user may have 5 minutes to make a move otherwise the game will pick a random move for them (often called a ",(0,r.kt)("inlineCode",{parentName:"p"},"zombie round"),"). The easiest way to do this is to use ",(0,r.kt)("inlineCode",{parentName:"p"},"createScheduledData")," to schedule a random move (assume the player will not submit a move), and then cancel it if they actually do make a move."),(0,r.kt)("h2",{id:"2-synchronizing-access-to-a-shared-state"},"2. Synchronizing access to a shared state"),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"/ja/home/read-write-L2-state/parallelism"},"parallelism")))}m.isMDXComponent=!0}}]);